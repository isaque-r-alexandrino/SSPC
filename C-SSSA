import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.widgets import Button, TextBox, Slider
from numba import jit
import sys
from datetime import datetime

# Otimização com numba para cálculos gravitacionais
@jit(nopython=True)
def calculate_gravitational_force(mass1, mass2, pos1, pos2, G):
    """Calcula força gravitacional entre dois corpos de forma otimizada"""
    r_vec = pos2 - pos1
    r_mag = np.linalg.norm(r_vec)
    
    if r_mag == 0:
        return np.zeros(2), r_mag
    
    force_mag = G * mass1 * mass2 / (r_mag**2)
    force_vec = force_mag * (r_vec / r_mag)
    
    return force_vec, r_mag

class UnitConverter:
    """Conversor de unidades para facilitar a entrada de dados"""
    @staticmethod
    def parse_value(input_str):
        """Converte string com notação científica para float"""
        try:
            return float(input_str)
        except ValueError:
            # Tenta converter notações como "1.5e10", "2.3E-5", etc.
            if 'e' in input_str.lower():
                base, exp = input_str.lower().split('e')
                return float(base) * (10 ** float(exp))
            return float(input_str)

class Body:
    def __init__(self, mass, x, y, vx, vy, radius, color, name):
        self.mass = mass
        self.pos = np.array([x, y], dtype=float)
        self.vel = np.array([vx, vy], dtype=float)
        self.radius = radius
        self.color = color
        self.name = name
        self.force = np.zeros(2)
        self.acceleration = np.zeros(2)
        self.trail = []
        self.max_trail_length = 1000
        self.energy = 0
        
        # Histórico para análise
        self.pos_history = []
        self.vel_history = []
        self.energy_history = []

    def reset_force(self):
        self.force = np.zeros(2)

    def add_force(self, other, G):
        """Calcula a força gravitacional entre dois corpos"""
        force_vec, r_mag = calculate_gravitational_force(
            self.mass, other.mass, self.pos, other.pos, G
        )
        
        # Verificar colisão com base nos raios reais
        if r_mag < (self.radius + other.radius):
            self.handle_collision(other)
            return
            
        self.force += force_vec

    def handle_collision(self, other):
        """Trata colisões entre corpos (fusão simples)"""
        # Para simplicidade, apenas para a simulação quando há colisão
        print(f"COLISÃO DETECTADA: {self.name} e {other.name}")
        # Em uma versão mais avançada, implementar conservação de momento

    def update(self, dt):
        """Atualiza posição e velocidade usando Velocity Verlet completo"""
        # Salvar aceleração anterior
        old_acceleration = self.acceleration.copy()
        
        # Calcular nova aceleração
        self.acceleration = self.force / self.mass
        
        # Velocity Verlet completo
        if len(self.pos_history) > 0:
            # Usar aceleração anterior para atualização de posição
            self.pos += self.vel * dt + 0.5 * old_acceleration * dt**2
        else:
            # Primeira iteração - usar Euler simples
            self.pos += self.vel * dt + 0.5 * self.acceleration * dt**2
        
        # Atualizar velocidade com média das acelerações
        self.vel += 0.5 * (old_acceleration + self.acceleration) * dt
        
        # Adicionar ao histórico
        self.trail.append(self.pos.copy())
        self.pos_history.append(self.pos.copy())
        self.vel_history.append(self.vel.copy())
        
        # Manter trilha com tamanho limitado
        if len(self.trail) > self.max_trail_length:
            self.trail.pop(0)
        if len(self.pos_history) > 10000:  # Limitar histórico
            self.pos_history.pop(0)
            self.vel_history.pop(0)

    def calculate_energy(self, other_bodies, G):
        """Calcula energia cinética e potencial"""
        # Energia cinética
        ek = 0.5 * self.mass * np.linalg.norm(self.vel)**2
        
        # Energia potencial
        ep = 0
        for other in other_bodies:
            if other != self:
                r_mag = np.linalg.norm(other.pos - self.pos)
                if r_mag > 0:
                    ep -= G * self.mass * other.mass / r_mag
        
        self.energy = ek + ep
        self.energy_history.append(self.energy)
        
        return self.energy

class SolarSystemSimulator:
    def __init__(self):
        self.bodies = []
        self.time = 0
        self.dt = 3600 * 24  # 1 dia em segundos padrão
        self.paused = False
        self.simulation_speed = 1.0
        self.G = 6.67430e-11  # Constante gravitacional
        
        # Configuração da figura
        self.fig, self.ax = plt.subplots(figsize=(14, 10))
        plt.subplots_adjust(bottom=0.25, top=0.95)
        
        # Sistema de coordenadas dinâmico
        self.auto_scale = True
        self.fixed_scale = 1e12
        
        self.setup_ui()
        
    def setup_ui(self):
        """Configura a interface do usuário melhorada"""
        axcolor = 'lightgoldenrodyellow'
        
        # Inputs para novo corpo - layout melhorado
        self.ax_name = plt.axes([0.05, 0.05, 0.08, 0.04])
        self.ax_mass = plt.axes([0.05, 0.10, 0.08, 0.04])
        self.ax_x = plt.axes([0.05, 0.15, 0.08, 0.04])
        self.ax_y = plt.axes([0.05, 0.20, 0.08, 0.04])
        self.ax_vx = plt.axes([0.15, 0.10, 0.08, 0.04])
        self.ax_vy = plt.axes([0.15, 0.15, 0.08, 0.04])
        self.ax_radius = plt.axes([0.15, 0.05, 0.08, 0.04])
        
        self.text_name = TextBox(self.ax_name, 'Nome', initial='Corpo')
        self.text_mass = TextBox(self.ax_mass, 'Massa (kg)', initial='1e30')
        self.text_x = TextBox(self.ax_x, 'Pos X (m)', initial='0')
        self.text_y = TextBox(self.ax_y, 'Pos Y (m)', initial='0')
        self.text_vx = TextBox(self.ax_vx, 'Vel X (m/s)', initial='0')
        self.text_vy = TextBox(self.ax_vy, 'Vel Y (m/s)', initial='0')
        self.text_radius = TextBox(self.ax_radius, 'Raio (m)', initial='1e9')
        
        # Botões principais
        self.ax_add = plt.axes([0.25, 0.05, 0.08, 0.04])
        self.ax_pause = plt.axes([0.25, 0.10, 0.08, 0.04])
        self.ax_reset = plt.axes([0.25, 0.15, 0.08, 0.04])
        self.ax_clear = plt.axes([0.25, 0.20, 0.08, 0.04])
        
        self.btn_add = Button(self.ax_add, 'Adicionar')
        self.btn_pause = Button(self.ax_pause, 'Pausar')
        self.btn_reset = Button(self.ax_reset, 'Resetar')
        self.btn_clear = Button(self.ax_clear, 'Limpar Trilhas')
        
        # Controles de simulação
        self.ax_speed = plt.axes([0.40, 0.05, 0.15, 0.03])
        self.ax_dt = plt.axes([0.40, 0.10, 0.15, 0.03])
        self.ax_scale = plt.axes([0.40, 0.15, 0.15, 0.03])
        
        self.slider_speed = Slider(self.ax_speed, 'Velocidade', 0.1, 10.0, valinit=1.0)
        self.slider_dt = Slider(self.ax_dt, 'Δt (horas)', 0.1, 240.0, valinit=24.0)
        self.slider_scale = Slider(self.ax_scale, 'Escala Fixa (m)', 1e9, 1e13, valinit=1e12)
        
        # Botões de utilidade
        self.ax_export = plt.axes([0.60, 0.05, 0.08, 0.04])
        self.ax_toggle_scale = plt.axes([0.60, 0.10, 0.08, 0.04])
        self.ax_info = plt.axes([0.60, 0.15, 0.08, 0.04])
        
        self.btn_export = Button(self.ax_export, 'Exportar')
        self.btn_toggle_scale = Button(self.ax_toggle_scale, 'Escala Auto')
        self.btn_info = Button(self.ax_info, 'Info Energia')
        
        # Conectar eventos
        self.btn_add.on_clicked(self.add_body)
        self.btn_pause.on_clicked(self.toggle_pause)
        self.btn_reset.on_clicked(self.reset_simulation)
        self.btn_clear.on_clicked(self.clear_trails)
        self.btn_export.on_clicked(self.export_data)
        self.btn_toggle_scale.on_clicked(self.toggle_auto_scale)
        self.btn_info.on_clicked(self.show_energy_info)
        
        self.slider_speed.on_changed(self.update_simulation_speed)
        self.slider_dt.on_changed(self.update_time_step)
        self.slider_scale.on_changed(self.update_fixed_scale)
        
    def add_body(self, event):
        """Adiciona um novo corpo baseado nos inputs do usuário"""
        try:
            # Usar o conversor para parsear valores
            mass = UnitConverter.parse_value(self.text_mass.text)
            x = UnitConverter.parse_value(self.text_x.text)
            y = UnitConverter.parse_value(self.text_y.text)
            vx = UnitConverter.parse_value(self.text_vx.text)
            vy = UnitConverter.parse_value(self.text_vy.text)
            radius = UnitConverter.parse_value(self.text_radius.text)
            name = self.text_name.text
            
            # Gerar cor aleatória
            color = np.random.rand(3,)
            
            new_body = Body(mass, x, y, vx, vy, radius, color, name)
            self.bodies.append(new_body)
            
            print(f"Corpo '{name}' adicionado!")
            print(f"  Massa: {mass:.2e} kg")
            print(f"  Posição: ({x:.2e}, {y:.2e}) m")
            print(f"  Velocidade: ({vx:.2e}, {vy:.2e}) m/s")
            print(f"  Raio: {radius:.2e} m")
            
        except ValueError as e:
            print(f"Erro nos valores de entrada: {e}")
            print("Use notação científica (ex: 1.5e10) ou números decimais")
    
    def toggle_pause(self, event):
        self.paused = not self.paused
        self.btn_pause.label.set_text('Continuar' if self.paused else 'Pausar')
        plt.draw()
    
    def reset_simulation(self, event):
        self.bodies = []
        self.time = 0
        print("Simulação resetada!")
    
    def clear_trails(self, event):
        for body in self.bodies:
            body.trail = []
        print("Trilhas limpas!")
    
    def update_simulation_speed(self, val):
        self.simulation_speed = val
    
    def update_time_step(self, val):
        self.dt = val * 3600  # Converter horas para segundos
    
    def update_fixed_scale(self, val):
        self.fixed_scale = val
    
    def toggle_auto_scale(self, event):
        self.auto_scale = not self.auto_scale
        mode = "AUTO" if self.auto_scale else "FIXA"
        self.btn_toggle_scale.label.set_text(f'Escala {mode}')
        print(f"Escala {mode} ativada")
        plt.draw()
    
    def export_data(self, event):
        """Exporta dados da simulação para arquivo"""
        if not self.bodies:
            print("Nenhum corpo para exportar!")
            return
            
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"simulation_data_{timestamp}.txt"
        
        with open(filename, 'w') as f:
            f.write(f"# Simulação Solar System - {timestamp}\n")
            f.write(f"# Tempo total: {self.time/3600/24:.2f} dias\n")
            f.write(f"# DT: {self.dt/3600:.2f} horas\n")
            f.write(f"# G: {self.G}\n\n")
            
            for body in self.bodies:
                f.write(f"[{body.name}]\n")
                f.write(f"Massa: {body.mass:.6e} kg\n")
                f.write(f"Posição: {body.pos[0]:.6e}, {body.pos[1]:.6e} m\n")
                f.write(f"Velocidade: {body.vel[0]:.6e}, {body.vel[1]:.6e} m/s\n")
                f.write(f"Raio: {body.radius:.6e} m\n")
                f.write(f"Energia: {body.energy:.6e} J\n\n")
        
        print(f"Dados exportados para {filename}")
    
    def show_energy_info(self, event):
        """Mostra informações de energia do sistema"""
        if not self.bodies:
            print("Nenhum corpo na simulação!")
            return
            
        total_energy = 0
        print("\n=== INFORMAÇÕES DE ENERGIA ===")
        for body in self.bodies:
            energy = body.calculate_energy(self.bodies, self.G)
            total_energy += energy
            print(f"{body.name}: {energy:.6e} J")
        
        print(f"Energia total do sistema: {total_energy:.6e} J")
        print(f"Conservação de energia: {abs(total_energy):.6e} J")
    
    def calculate_view_limits(self):
        """Calcula limites de visualização dinamicamente"""
        if not self.bodies or self.auto_scale == False:
            return -self.fixed_scale, self.fixed_scale, -self.fixed_scale, self.fixed_scale
        
        positions = np.array([body.pos for body in self.bodies])
        if len(positions) == 0:
            return -1e11, 1e11, -1e11, 1e11
        
        max_extent = np.max(np.abs(positions)) * 1.5
        max_extent = max(max_extent, 1e10)  # Mínimo de 10 milhões de km
        
        return -max_extent, max_extent, -max_extent, max_extent
    
    def calculate_forces(self):
        """Calcula todas as forças entre os corpos"""
        for body in self.bodies:
            body.reset_force()
        
        for i, body1 in enumerate(self.bodies):
            for body2 in self.bodies[i+1:]:
                body1.add_force(body2, self.G)
                body2.add_force(body1, self.G)
    
    def update_bodies(self):
        """Atualiza todas as posições dos corpos"""
        effective_dt = self.dt * self.simulation_speed
        
        for body in self.bodies:
            body.update(effective_dt)
    
    def init_animation(self):
        self.ax.clear()
        xlim1, xlim2, ylim1, ylim2 = self.calculate_view_limits()
        self.ax.set_xlim(xlim1, xlim2)
        self.ax.set_ylim(ylim1, ylim2)
        self.ax.set_xlabel('Distância X (m)')
        self.ax.set_ylabel('Distância Y (m)')
        self.ax.set_title('Simulador do Sistema Solar - Configuração Inicial')
        self.ax.grid(True, alpha=0.3)
        self.ax.set_aspect('equal')
        return []
    
    def animate(self, frame):
        if self.paused or len(self.bodies) == 0:
            return []
        
        # Atualizar física
        self.calculate_forces()
        self.update_bodies()
        self.time += self.dt * self.simulation_speed
        
        # Calcular energias
        for body in self.bodies:
            body.calculate_energy(self.bodies, self.G)
        
        # Atualizar visualização
        self.ax.clear()
        xlim1, xlim2, ylim1, ylim2 = self.calculate_view_limits()
        self.ax.set_xlim(xlim1, xlim2)
        self.ax.set_ylim(ylim1, ylim2)
        self.ax.set_xlabel('Distância X (m)')
        self.ax.set_ylabel('Distância Y (m)')
        
        scale_mode = "AUTO" if self.auto_scale else "FIXA"
        self.ax.set_title(
            f'Simulador do Sistema Solar | '
            f'Tempo: {self.time/3600/24:.1f} dias | '
            f'Corpos: {len(self.bodies)} | '
            f'Escala: {scale_mode}'
        )
        self.ax.grid(True, alpha=0.3)
        self.ax.set_aspect('equal')
        
        # Desenhar corpos e trilhas
        for body in self.bodies:
            # Desenhar trilha
            if len(body.trail) > 1:
                trail = np.array(body.trail)
                self.ax.plot(trail[:, 0], trail[:, 1], color=body.color, 
                           alpha=0.7, linewidth=1.5, linestyle='-')
            
            # Calcular tamanho visual do corpo (proporcional à raiz cúbica da massa)
            visual_radius = max(1e8, body.radius)  # Mínimo para visualização
            if body.radius <= 0:
                visual_radius = max(5e8, np.cbrt(body.mass) * 1e3)
            
            # Desenhar corpo
            circle = plt.Circle(body.pos, visual_radius, color=body.color, alpha=0.8)
            self.ax.add_patch(circle)
            
            # Adicionar rótulo
            self.ax.text(body.pos[0], body.pos[1] + visual_radius * 1.5, 
                        f'{body.name}\n{body.mass:.2e} kg', 
                        ha='center', va='bottom', fontsize=8,
                        bbox=dict(boxstyle="round,pad=0.3", facecolor='white', alpha=0.7))
        
        # Adicionar informações na tela
        info_text = (
            f"Velocidade: {self.simulation_speed:.1f}x\n"
            f"Δt: {self.dt/3600:.1f} h\n"
            f"Escala: {scale_mode}\n"
            f"Corpos: {len(self.bodies)}"
        )
        self.ax.text(0.02, 0.98, info_text, transform=self.ax.transAxes,
                    verticalalignment='top', fontsize=9,
                    bbox=dict(boxstyle="round,pad=0.5", facecolor='white', alpha=0.8))
        
        return []
    
    def run(self):
        """Executa a simulação"""
        print("=== SIMULADOR DO SISTEMA SOLAR AVANÇADO ===")
        print("\n INSTRUÇÕES:")
        print("1. ADICIONAR CORPOS:")
        print("   • Preencha todos os campos (use notação científica: 1.5e10)")
        print("   • Massa: massa em kg")
        print("   • Pos X/Y: posição em metros")
        print("   • Vel X/Y: velocidade em m/s")
        print("   • Raio: raio físico em metros")
        print("   • Nome: identificação do corpo")
        
        print("\n CONTROLES:")
        print("   • Velocidade: controla velocidade da simulação")
        print("   • Δt: passo de tempo em horas")
        print("   • Escala: tamanho da visualização")
        print("   • Escala Auto/Fixa: alterna entre escala automática e fixa")
        print("   • Exportar: salva dados da simulação")
        print("   • Info Energia: mostra conservação de energia")
        print("   • Limpar Trilhas: remove trilhas orbitais")
        
        print("\n DICAS:")
        print("   • Use valores realistas para órbitas estáveis")
        print("   • Comece com poucos corpos para testar")
        print("   • A energia total deve ser aproximadamente conservada")
        print("   • Use escala automática para sistemas dinâmicos")
        
        # Iniciar animação
        ani = animation.FuncAnimation(
            self.fig, self.animate, init_func=self.init_animation,
            interval=50, blit=False, cache_frame_data=False
        )
        
        plt.show()

if __name__ == "__main__":
    simulator = SolarSystemSimulator()
    simulator.run()
